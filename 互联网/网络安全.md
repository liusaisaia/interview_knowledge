······
[TOC]
······


# **目录**

## <a href="#tongyuan">一、同源策略</a>
## <a href="#XSS">二、XSS</a>
## <a href="#CSRF">二、CSRF</a>
## <a href="#liuliang">三、流量劫持</a>
## <a href="#anquan">四、浏览器网络安全</a>
## <a href="#liulan">五、浏览器系统安全</a>

### [一、同源策略](#tongyuan)


所谓的的源是指URL，可以是连接： https://github.com/liusaisaia

|  名称   | 举例  |
|  ----  | ----  |
|  协议   | http、https |
| 域名  | `github.com` |
| 端口  | 8080、 8081 |

>其中，如果URL上未标明端口，那么http默认就是80端口，https默认443端口

所谓的同源策略就是（同端口、同域名、同源策略）

浏览器默认两个相同的源之间是可以访问资源和操作DOM的。两个不同的源之间若想相互访问资源或者DOM，那么就会有一套记住的安全策略的制约，这就是同源策略。

### 1.1为什么需要同源策略
主要是表现在DOM、Web数据和网络三个层面

* 第一个，DOM层面

&emsp; &emsp;&emsp;同源策略限制了来自不同源的JavaScript脚本对当前DOM对象读写操作。

当你在A页面，通过`<a href="XXX">`的形式打开B页面，经过代码可以将A页面的内容隐藏掉:
```js
let pdom = opener.document;
pdom.body.style.display = 'none';
```
这种情况是同源情况下DOM的一个操作，不同源的情况下是无法操作的

* 第二个，是数据层面


&emsp; &emsp;&emsp; 同源策略限制了不同源的站点读取当前站的Cookie、indexedDB(是一种使用浏览器存储大量数据的方法，它创造的数据可以被查询，并且可以离线使用)、LocalStorage等数据

* 第三个，网络层面
限制了通过XMLHttpRequest等方式将站点的数据发送给不同源的站点

### [二、XSS](#XSS)

### 什么是XSS

XSS(Cross Site Script) 跨站脚本攻击。指的是攻击者想网页注入恶意的客户端代码，通过恶意的脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。例如：

* 可以窃取Cookie信息，恶意的javaScript可以通过document.cookie获取cookie信息，然后通过XMLHttpRequest或者Fetch加上CORS功能将数据发送给恶意服务器，恶意服务器拿到用户的Cookie信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
* 可以监听用户的行为，可以使用addEventLisener接口来监听键盘事件，获取比如信用卡等信息，进行恶意操作

注入恶意脚本分3种方式：

* 存储型： 攻击被存储在服务端，常见的是在评论区插入攻击脚本，如果存到服务端，那么所有的用户都会受到攻击
* 反射性： 攻击者将脚本混在URL里，服务端接收到URL将恶意代码当做参数取出并拼接在HML里返回，浏览器解析此HTML后执行恶意代码，
* DOM型： 攻击者将恶意脚本注入用户的页面中。

### XSS防御

* 输入检查： 对输入内容进行过滤或者转义
* 设置httpOnly： 可以防止JavaScript获取Cookie，只能在HTTP请求过程中使用cookie
* 开启CSP白名单： 可以阻止白名单以外的资源加载和运行

### [二、CSRF](#CSRF)

跨站请求伪造

是一种劫持受信任用户向服务器发送预期请求的攻击方式，它是攻击者借助受害者的Cookie片区服务器的信任，但是它并不能拿到Cookie，也看不到Cookie的内容，它能做的就是给服务器发送请求，然后执行请求中所描述的命令，以此来改变服务器中的数据，也就是并不能窃取到服务器中的数据。

例如：

* 方式一、自动发起get请求
```js
<img src="http://····">
```
在img标签里面隐藏请求 页面加载时发起请求
* 方式二、发起POST请求
```js
<form action="https://XXXX"></form>
```
构建一个隐藏的form表单 用户打开网站自动进行表单提交
* 方法三、引诱用户点击链接

使用引诱使用户点击链接 触发请求

### 防御CSRF攻击

* 验证Token: 浏览器请求服务器时，服务器返回token，之后每个请求要同时带上token和cookie才会被认为是合法的请求
* 验证Referer：通过验证请求头的Referer来验证来源站点，但请求头很容易伪造
* 设置SamSite： 设置Cookie的SamSite，可以让Cookie不随跨站请求发出，但是取决于浏览器的兼容

### [三、流量劫持](#liuliang)
流量劫持分两种： DNS劫持和HTTP劫持，目的都是一样的，就当用户访问`github.com`的时候，给你展示的并不是或者不完全是`github.com`提供的内容
#### DNS劫持
也叫域名劫持。

当用户通过某一个域名访问一个站点的时候，被篡改的 DNS 服务器返回的是一个恶意的钓鱼站点的 IP，用户就被劫持到了恶意钓鱼站点，然后继而会被钓鱼输入各种账号密码信息，泄漏隐私。
#### HTTP劫持

HTTP 劫持主要是当用户访问某个站点的时候会经过运营商网络，而不法运营商和黑产勾结能够截获 HTTP 请求返回内容，并且能够篡改内容，然后再返回给用户，从而实现劫持页面。


轻则插入小广告，重则直接篡改成钓鱼网站页面骗用户隐私，就好比 jsliang 访问某 XXDN 网站，会出现 Google 广告，实际上问了其他人的是不会有这个的。

能够实施流量劫持的根本原因，是 HTTP 协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验。如果能解决这个问题，则流量劫持将无法轻易发生。

所以防止 HTTP 劫持的方法只有将内容加密，让劫持者无法破解篡改，这样就可以防止 HTTP 劫持了。

HTTPS 是基于 SSL 协议的安全加密网络应用层协议，相当于 HTTP + SSL，可以很好地防止 HTTP 劫持。


### [四、浏览器网络安全](#anquan)
HTTP 在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，在通信过程中的一切内容都在中间人的掌握中。

使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击。

具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。

比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。

或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。
### [五、浏览器网络安全](#liulan)
浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序。

其中最常见的攻击方式是利用缓冲区溢出，不过需要注意这种类型的攻击和 XSS 注入的脚本是不一样的。

XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。
通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。
渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限。

基于此，在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。

将渲染进程和操作系统隔离的这道墙就是安全沙箱。
